
# 如果一个类定义了解构函数，那么您必须同时定义或删除拷贝构造函数和拷贝赋值函数，否则出错。

当一个类定义了析构函数，这通常意味着它管理着一些需要特别处理的资源，比如动态分配的内存、文件句柄或其他形式的资源。如果不同时定义或删除拷贝构造函数和拷贝赋值函数，可能会导致资源管理上的错误，如资源泄露或双重释放。

原因在于，如果你没有显式定义或删除拷贝构造函数和拷贝赋值函数，编译器会为你生成默认的版本。这些默认版本只会执行成员变量的浅拷贝（shallow copy），这对于管理资源的类来说通常是不足够的。浅拷贝可能会导致两个对象指向同一资源，而当一个对象被销毁时，它的析构函数会释放这个资源，留下另一个对象持有一个已经被释放的资源的指针，从而可能导致程序崩溃或未定义的行为。

考虑下面这段代码：

```cpp
struct Resource {
  int* data;
  Resource() {
    data = new int[10];
    std::cout << "资源获取\n";
  }
  ~Resource() {
    delete[] data;
    std::cout << "资源释放\n";
  }
};
void func1() {
  Resource a;
  Resource b = a;  // 调用默认的拷贝构造函数
  std::cout << a.data << '\n';
  std::cout << b.data << '\n';
}
int main() {
  func1();
}
```

这是执行结果，显示出错：

```bash
资源获取
0x55fd81099eb0
0x55fd81099eb0
资源释放
free(): double free detected in tcache 2
[1]    20525 IOT instruction
```

# 如果一个类定义了拷贝构造函数，那么您必须同时定义或删除拷贝赋值函数，否则出错，删除可导致低效。

当一个类定义了拷贝构造函数，通常意味着它进行了一些非默认的拷贝行为，比如深拷贝（deep copy）或者特别的资源管理。如果在这种情况下不同时定义或删除拷贝赋值函数，可能会导致类的行为不一致或者资源管理出现问题。

默认的拷贝赋值函数只会进行成员的浅拷贝。如果类需要进行深拷贝或有特殊的拷贝逻辑，而只定义了拷贝构造函数而没有定义拷贝赋值函数，那么在使用赋值操作时，会出现不一致的行为：拷贝构造函数会执行深拷贝，而拷贝赋值操作则是浅拷贝，可能导致资源泄漏或者其他问题。

参考代码：

```cpp
struct MyClass {
  MyClass() {
    data = new int(42);
    std::cout << "分配资源\n";
  }

  // 定义了拷贝构造函数进行深拷贝
  MyClass(const MyClass& other) {
    data = new int(*other.data);
    std::cout << "拷贝构造\n";
  }

  ~MyClass() {
    std::cout << "释放资源\n";
    delete data;
  }

 private:
  int* data;
};

void function() {
  MyClass a;
  MyClass b = a;  // 使用拷贝构造函数
  MyClass c;
  c = a;  // 使用默认的拷贝赋值操作
}  // 函数结束时，a, b, c 都会被销毁

int main() { function(); }
```

运行结果：

```bash
分配资源
拷贝构造
分配资源
释放资源
释放资源
释放资源
free(): double free detected in tcache 2
[1]    23667 IOT instruction
```

# 如果一个类定义了移动构造函数，那么您必须同时定义或删除移动赋值函数，否则出错，删除可导致低效。

# 如果一个类定义了拷贝构造函数或拷贝赋值函数，那么您必须最好同时定义移动构造函数或移动赋值函数，否则低效。


**tip:如果有移动赋值函数，可以删除拷贝赋值函数**

